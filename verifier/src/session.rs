use axum::{Json, extract::State, response::IntoResponse};
use serde::{Deserialize, Serialize};
use uuid::Uuid;

use crate::{NotaryGlobals, SessionPhase};

/// Request object of the /session API.
#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct NotarizationSessionRequest {
    /// Maximum data that can be sent by the prover.
    pub max_sent_data: Option<usize>,
    /// Maximum data that can be received by the prover.
    pub max_recv_data: Option<usize>,
}

/// Request object of the /session API.
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct NotarizationSessionResponse {
    /// Unique session id that is generated by the notary and shared to the
    /// prover.
    pub session_id: String,
}

/// Handler to initialize and configure notarization
pub async fn initialize(State(notary_globals): State<NotaryGlobals>) -> impl IntoResponse {
    let session_id = Uuid::new_v4().to_string();

    // Store the configuration data in a temporary store
    notary_globals
        .store
        .lock()
        .await
        .insert(session_id.clone(), SessionPhase::Notarization);

    tracing::trace!("Latest store state: {:?}", notary_globals.store);

    Json(NotarizationSessionResponse { session_id })
}
