//! ZK-TLS Notary Library
//!
//! This crate provides a simple and reusable library for generating and verifying
//! zero-knowledge proofs of TLS sessions using the TLSN protocol. It enables
//! selective disclosure of data from authenticated TLS connections.
//!
//! # Overview
//!
//! The library is organized into three main components:
//!
//! - **Prover**: Generates proofs of TLS sessions with selective disclosure
//! - **Verifier**: Verifies proofs generated by the prover
//! - **Transcript**: Utilities for working with transcript commitments and secrets
//!
//! # Architecture
//!
//! The TLSN protocol involves three parties:
//!
//! 1. **Prover**: Connects to a server via MPC-TLS and generates proofs
//! 2. **Verifier**: Participates in MPC protocol and verifies the proofs
//! 3. **Server**: The target TLS server (unaware of the protocol)
//!
//! ```text
//! ┌─────────┐         ┌──────────┐         ┌────────┐
//! │ Prover  │◄───────►│ Verifier │         │ Server │
//! │         │  MPC    │          │         │        │
//! │         │◄────────────────────────────►│        │
//! └─────────┘         └──────────┘  TLS    └────────┘
//! ```
//!
//! # Features
//!
//! - **Selective Disclosure**: Reveal only specific parts of the TLS session
//! - **Hash Commitments**: Create commitments to data without revealing it
//! - **Type Safety**: Custom error types for clear error handling
//! - **Async/Await**: Built on async Rust for efficient I/O

pub mod error;
pub mod prover;
pub mod transcript;
pub mod verifier;

// Re-export public API
pub use error::ZkTlsNotaryError;
pub use prover::{Prover, ProverBuilder, ProverOutput, RevealConfig};
pub use transcript::{extract_received_commitments, extract_received_secrets};
pub use verifier::{VerifierOutput, verify};

/// Maximum number of bytes that can be sent from prover to server.
pub const MAX_SENT_DATA: usize = 1 << 12;

/// Maximum number of bytes that can be received by prover from server.
pub const MAX_RECV_DATA: usize = 1 << 14;

#[cfg(test)]
mod tests {
    use std::collections::HashMap;

    use axum::body::Bytes;
    use futures::join;
    use http_body_util::Empty;
    use hyper::Request;
    use server::{app::get_app, handle_connection};
    use shared::create_test_tls_config;
    use smol::net::unix::UnixStream;
    use tlsn::{
        config::{CertificateDer, ProtocolConfig, ProtocolConfigValidator, RootCertStore},
        connection::ServerName,
        prover::{ProverConfig, TlsConfig},
        verifier::VerifierConfig,
    };

    use crate::{MAX_RECV_DATA, MAX_SENT_DATA, Prover, prover::RevealConfig, verify};

    #[test]
    fn test_tls_notary_end_to_end() {
        shared::init_test_logging();

        smol::block_on(async {
            let test_tls_config = create_test_tls_config().unwrap();

            let (prover_server_socket, server_socket) = UnixStream::pair().unwrap();
            let (prover_verifier_socket, verifier_socket) = UnixStream::pair().unwrap();

            let server_name = ServerName::Dns("localhost".to_string().try_into().unwrap());

            let request = Request::builder()
                .method("GET")
                .uri("/api/balance/alice")
                .header("content-type", "application/json")
                .header("Connection", "close")
                .body(Empty::<Bytes>::new())
                .expect("Failed to build request");
            let mut tls_config_builder = TlsConfig::builder();
            tls_config_builder.root_store(RootCertStore {
                roots: vec![CertificateDer(test_tls_config.cert_bytes.clone())],
            });
            let tls_config = tls_config_builder.build().unwrap();

            let mut prover_config_builder = ProverConfig::builder();
            prover_config_builder
                .server_name(server_name.clone())
                .tls_config(tls_config)
                .protocol_config(
                    ProtocolConfig::builder()
                        .max_sent_data(MAX_SENT_DATA)
                        .max_recv_data(MAX_RECV_DATA)
                        .build()
                        .unwrap(),
                );

            let prover_config = prover_config_builder.build().unwrap();

            let verifier_config = VerifierConfig::builder()
                .root_store(RootCertStore {
                    roots: vec![CertificateDer(test_tls_config.cert_bytes)],
                })
                .protocol_config_validator(
                    ProtocolConfigValidator::builder()
                        .max_sent_data(MAX_SENT_DATA)
                        .max_recv_data(MAX_RECV_DATA)
                        .build()
                        .unwrap(),
                )
                .build()
                .unwrap();

            let mut balances = HashMap::new();
            balances.insert("alice".to_string(), 100);
            let app = get_app(balances);
            let server_task = handle_connection(app, test_tls_config.server_config, server_socket);

            let prover = Prover::builder()
                .prover_config(prover_config)
                .request(request)
                .request_reveal_config(RevealConfig {
                    reveal_headers: vec!["content-type".into()],
                    commit_headers: vec!["connection".into()],
                    reveal_body_keypaths: vec![],
                    commit_body_keypaths: vec![],
                })
                .response_reveal_config(RevealConfig {
                    reveal_headers: vec![],
                    commit_headers: vec![],
                    reveal_body_keypaths: vec!["username".into()],
                    commit_body_keypaths: vec!["balance".into()],
                })
                .build()
                .unwrap();

            let prover_task = prover.prove(prover_verifier_socket, prover_server_socket);

            let verifier_task = verify(verifier_socket, verifier_config);

            let (server_result, prover_result, verifier_result) =
                join!(server_task, prover_task, verifier_task);

            server_result.expect("Server should complete successfully");
            let prover_output = prover_result.expect("Prover should complete successfully");
            let verifier_output = verifier_result.expect("Verifier should complete successfully");

            assert!(
                !prover_output.transcript_commitments.is_empty(),
                "Prover should produce transcript commitments"
            );
            assert!(
                !prover_output.transcript_secrets.is_empty(),
                "Prover should produce transcript secrets"
            );

            assert_eq!(
                verifier_output.server_name, "localhost",
                "Verifier should verify correct server name"
            );

            let sent_data = String::from_utf8(verifier_output.transcript.sent_unsafe().to_vec())
                .expect("Sent data should be valid UTF-8");
            let received_data =
                String::from_utf8(verifier_output.transcript.received_unsafe().to_vec())
                    .expect("Received data should be valid UTF-8");

            dbg!(&sent_data);
            dbg!(&received_data);

            assert!(
                received_data.contains("username"),
                "Response should contain username field"
            );
            assert!(
                received_data.contains("alice"),
                "Response should contain alice username"
            );

            assert!(
                sent_data.contains("GET /api/balance/alice"),
                "Request should be a GET to /api/balance/alice"
            );
        });
    }
}
